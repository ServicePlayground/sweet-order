# 백엔드 운영 단계 문제점 분석

## 📋 개요

본 문서는 SweetOrder 프로젝트의 백엔드 코드를 분석하여, 실제 운영 단계에서 발생할 수 있는 문제점들을 정리한 가이드입니다.

**분석 기준일**: 2025-01-23  
**분석 범위**: `apps/backend/src` 디렉토리 전체

---

## 🔴 심각한 문제점 (즉시 조치 필요)

### 1. 데이터베이스 연결 실패 시에도 애플리케이션 계속 실행

**위치**: `apps/backend/src/infra/database/prisma.service.ts` 33-51번 라인

**현재 구현**:

```33:51:apps/backend/src/infra/database/prisma.service.ts
  private async connectWithRetry(retries = 10, delayMs = 3000): Promise<void> {
    for (let i = 1; i <= retries; i++) {
      try {
        await this.$connect();
        this.logger.log("✅ Prisma DB 연결 성공");
        return;
      } catch (e: any) {
        const code = e?.code || e?.name || "UNKNOWN";
        const msg = e?.message || e?.toString?.() || e;
        this.logger.warn(`⚠️ Prisma 연결 실패 (${i}/${retries}) - ${code}: ${msg}`);
        if (i === retries) {
          this.logger.error("🚫 Prisma 연결 재시도 모두 실패 — 앱은 계속 실행됩니다(헬스는 200).");
          // 마지막에도 throw 하지 않음: 프로세스는 살아 있어야 App Runner 헬스체크 통과
          return;
        }
        await new Promise((r) => setTimeout(r, delayMs));
      }
    }
  }
```

**문제점**:

- 데이터베이스 연결이 실패해도 애플리케이션이 계속 실행됨
- Health Check는 통과하지만 실제 API 요청은 모두 실패
- 사용자는 서비스가 정상 작동하는 것으로 착각할 수 있음
- 데이터베이스 장애를 즉시 감지하지 못함

**위험성**:

- 모든 API 요청이 실패하지만 Health Check는 성공
- Nginx가 비정상 백엔드 인스턴스에 트래픽을 계속 라우팅
- PM2 프로세스가 다운되어도 Health Check가 성공으로 표시될 수 있음
- 장애 감지 지연으로 인한 서비스 다운타임 증가

**해결 방안**:

1. Health Check 엔드포인트에서 데이터베이스 연결 상태 확인
2. 데이터베이스 연결 실패 시 애플리케이션 시작 실패 처리 (선택적)
3. 연결 상태를 추적하는 플래그 추가 및 Health Check에서 확인

---

### 2. 운영 환경에서 에러 로깅 미작동

**위치**: `apps/backend/src/common/interceptors/error-response.interceptor.ts` 45-47번 라인

**현재 구현**:

```45:47:apps/backend/src/common/interceptors/error-response.interceptor.ts
    if (process.env.NODE_ENV === "development") {
      this.logger.error(`Error: ${request.method} ${request.url} - ${status}`, data);
    }
```

**문제점**:

- 운영 환경(staging, production)에서 에러 로깅이 비활성화됨
- 운영 환경에서 발생하는 에러를 추적할 수 없음
- 디버깅 및 모니터링 불가능

**위험성**:

- 운영 환경 장애 발생 시 원인 파악 불가능
- 에러 추적 및 분석 불가능
- 보안 사고 발생 시 로그 부재

**해결 방안**:

1. 운영 환경에서도 에러 로깅 활성화 (민감 정보 제외)
2. CloudWatch Logs 연동
3. 에러 로그 레벨 구분 (ERROR, WARN, INFO)
4. 구조화된 로깅 (JSON 형식)

---

### 3. Health Check 엔드포인트 검증 부족

**위치**: `apps/backend/src/main.ts` 44-46번 라인

**현재 구현**:

```44:46:apps/backend/src/main.ts
  httpAdapter.getInstance().get("/health", (_req: any, res: any) => {
    res.status(200).send("OK");
  });
```

**문제점**:

- 단순히 "OK"만 반환하여 실제 애플리케이션 상태를 확인하지 않음
- 데이터베이스 연결 상태 미확인
- 의존성 서비스(S3, Secrets Manager) 상태 미확인

**위험성**:

- 데이터베이스 연결이 끊어져도 Health Check가 성공으로 표시됨
- Nginx가 비정상 백엔드 인스턴스를 정상으로 인식하여 트래픽 라우팅
- PM2 프로세스가 다운되어도 Health Check가 성공으로 표시될 수 있음
- 실제 장애 발생 시 감지 불가

**해결 방안**:

1. Health Check 엔드포인트 개선:
   - 데이터베이스 연결 확인
   - 의존성 서비스 상태 확인 (S3 등)
   - 메모리/디스크 상태 확인
   - PM2 프로세스 상태 확인 (선택적)
2. Liveness vs Readiness 구분:
   - `/health/live`: 애플리케이션 프로세스 상태 (PM2 프로세스 실행 여부)
   - `/health/ready`: 서비스 준비 상태 (DB 연결, 의존성 서비스 등)

---

### 4. 외부 API 호출 시 타임아웃 및 재시도 설정 부족

**위치**: 
- `apps/backend/src/modules/business/services/nts-api.service.ts` 30-35번 라인
- `apps/backend/src/modules/business/services/kftc-api.service.ts` 27-32번 라인

**현재 구현**:

```30:35:apps/backend/src/modules/business/services/nts-api.service.ts
    // axios 인스턴스 생성
    this.axiosInstance = axios.create({
      baseURL: this.ntsApiUrl,
      headers: {
        "Content-Type": "application/json",
      },
    });
```

**문제점**:

- 타임아웃 설정 없음 (기본값 무한 대기)
- 재시도 로직 없음
- 외부 API 장애 시 요청이 무한정 대기할 수 있음

**위험성**:

- 외부 API 장애 시 요청이 블로킹되어 전체 서비스 영향
- 타임아웃 없이 무한 대기로 인한 리소스 고갈
- 사용자 요청 타임아웃 발생

**해결 방안**:

1. 타임아웃 설정 추가 (예: 10초)
2. 재시도 로직 구현 (최대 3회, 지수 백오프)
3. Circuit Breaker 패턴 적용
4. 외부 API 장애 시 폴백 처리

**참고**: `GoogleService`는 타임아웃 설정이 있음 (30초) - 좋은 예시

---

### 5. 트랜잭션 타임아웃 설정 부재

**위치**: Prisma 트랜잭션 사용 부분 (예: `order-create.service.ts`, `chat-message-create.service.ts`)

**현재 구현**:

```272:272:apps/backend/src/modules/order/services/order-create.service.ts
        return await this.prisma.$transaction(async (tx) => {
```

**문제점**:

- 트랜잭션 타임아웃 설정 없음
- 장시간 실행되는 트랜잭션으로 인한 데드락 가능
- 데이터베이스 연결 풀 고갈 가능

**위험성**:

- 트랜잭션이 무한정 대기하여 다른 요청 블로킹
- 데이터베이스 연결 풀 고갈
- 전체 서비스 성능 저하

**해결 방안**:

1. 트랜잭션 타임아웃 설정 추가:
   ```typescript
   await this.prisma.$transaction(async (tx) => {
     // 트랜잭션 로직
   }, {
     maxWait: 5000, // 최대 대기 시간 (5초)
     timeout: 10000, // 타임아웃 (10초)
   });
   ```
2. 트랜잭션 격리 수준 명시
3. 트랜잭션 실행 시간 모니터링
4. 장시간 실행 트랜잭션 알림

---

## 🟡 중간 수준 문제점 (단기 조치 권장)

### 6. Rate Limiting 설정이 전역으로만 적용

**위치**: `apps/backend/src/app.module.ts` 31-36번 라인

**현재 구현**:

```31:36:apps/backend/src/app.module.ts
    // Rate Limiting 모듈
    ThrottlerModule.forRoot([
      {
        ttl: 60000, // 1분
        limit: 100, // 1분당 100회 요청 제한
      },
    ]),
```

**문제점**:

- 모든 엔드포인트에 동일한 Rate Limiting 적용
- 인증 관련 엔드포인트와 일반 API에 동일한 제한
- 공격에 취약한 엔드포인트에 대한 추가 보호 부재

**위험성**:

- 인증 엔드포인트에 대한 브루트포스 공격 가능
- 특정 엔드포인트에 대한 집중 공격 가능
- 비용이 많이 드는 작업(파일 업로드 등)에 대한 제한 부족

**해결 방안**:

1. 엔드포인트별 Rate Limiting 설정
2. 인증 관련 엔드포인트에 더 엄격한 제한 적용
3. IP 기반 Rate Limiting 추가
4. 사용자별 Rate Limiting (로그인 사용자)

---

### 7. 외부 API 에러 처리 일관성 부족

**위치**: 
- `apps/backend/src/modules/business/services/nts-api.service.ts` 88-99번 라인
- `apps/backend/src/modules/business/services/kftc-api.service.ts` 83-94번 라인

**현재 구현**:

```88:99:apps/backend/src/modules/business/services/nts-api.service.ts
    } catch (error: any) {
      if (error.message) {
        throw new BadRequestException(error.message);
      }

      const statusCode = error.response?.data?.status_code;
      const errorMessage =
        NTS_API_ERROR_MESSAGES[statusCode as keyof typeof NTS_API_ERROR_MESSAGES];

      this.logger.error(`사업자등록번호 진위확인 실패: ${errorMessage}`);
      throw new BadRequestException(errorMessage);
    }
```

**문제점**:

- 외부 API 에러를 모두 `BadRequestException`으로 변환
- 네트워크 에러와 비즈니스 로직 에러 구분 없음
- 재시도 가능한 에러와 불가능한 에러 구분 없음

**위험성**:

- 일시적 네트워크 에러를 영구적 에러로 처리
- 사용자에게 부정확한 에러 메시지 제공
- 디버깅 어려움

**해결 방안**:

1. 에러 타입별 적절한 예외 처리
2. 재시도 가능한 에러와 불가능한 에러 구분
3. 구조화된 에러 응답
4. 외부 API 에러 로깅 강화

---

### 8. 민감 정보 로그 노출 위험

**위치**: 여러 위치 (에러 로깅, 환경 변수 처리 등)

**문제점**:

- 에러 로깅 시 민감 정보(비밀번호, 토큰 등) 노출 가능
- 환경 변수 값이 로그에 노출될 수 있음
- 스택 트레이스에 민감 정보 포함 가능

**위험성**:

- 로그 유출 시 보안 사고 발생
- 개인정보 보호법 위반 가능
- 인증 정보 유출로 인한 계정 탈취

**해결 방안**:

1. 로깅 전 민감 정보 마스킹
2. 환경 변수 값 로깅 금지
3. 스택 트레이스에서 민감 정보 제거
4. 로그 레벨별 필터링

**참고**: `PhoneUtil.maskPhone()`은 좋은 예시

---

### 9. 파일 업로드 크기 제한이 하드코딩

**위치**: `apps/backend/src/modules/upload/constants/upload.constants.ts` 65번 라인

**현재 구현**:

```65:65:apps/backend/src/modules/upload/constants/upload.constants.ts
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB in bytes
```

**문제점**:

- 파일 크기 제한이 코드에 하드코딩됨
- 환경별로 다른 제한 설정 불가능
- 운영 중 제한 변경 시 코드 수정 필요

**해결 방안**:

1. 환경 변수로 파일 크기 제한 설정 가능하게 변경
2. 파일 타입별 다른 크기 제한 적용 가능
3. 동적 설정 변경 지원 (선택적)

---

### 10. 데이터베이스 연결 풀 설정 부재

**위치**: `apps/backend/src/infra/database/prisma.service.ts`

**문제점**:

- Prisma 연결 풀 설정이 명시적으로 설정되지 않음
- 기본값에 의존하여 운영 환경에서 최적화 불가능
- 트래픽 증가 시 연결 풀 고갈 가능

**위험성**:

- 높은 트래픽 시 데이터베이스 연결 부족
- 연결 대기로 인한 응답 지연
- 전체 서비스 성능 저하

**해결 방안**:

1. `DATABASE_URL`에 연결 풀 파라미터 추가:
   ```
   ?connection_limit=10&pool_timeout=20
   ```
2. 환경별 다른 연결 풀 설정
3. 연결 풀 사용량 모니터링

---

### 11. 환경 변수 검증 부족

**위치**: `apps/backend/src/infra/database/prisma.service.ts` 9-17번 라인

**현재 구현**:

```9:17:apps/backend/src/infra/database/prisma.service.ts
  constructor(private readonly configService: ConfigService) {
    const databaseUrl = configService.get<string>("DATABASE_URL");
    const nodeEnv = configService.get<string>("NODE_ENV");

    if (!databaseUrl) {
      throw new Error(
        `DATABASE_URL이 설정되어 있지 않습니다. .env.${nodeEnv} 파일 또는 환경 변수를 확인하세요.`,
      );
    }
```

**문제점**:

- `DATABASE_URL`만 검증하고 다른 필수 환경 변수는 검증하지 않음
- 필수 환경 변수 목록이 명확하지 않음
- 환경 변수 누락 시 런타임 에러 발생 가능

**위험성**:

- 필수 환경 변수 누락 시 런타임 에러 발생
- 문제 발생 시점이 늦어져 디버깅 어려움
- 운영 환경에서 예상치 못한 장애 발생

**해결 방안**:

1. 필수 환경 변수 목록 정의 및 검증 로직 추가
2. 환경 변수 누락 시 애플리케이션 시작 실패 처리
3. 명확한 에러 메시지 제공
4. 환경 변수 스키마 정의 (Zod 등 사용)

---

### 12. PM2 프로세스 관리 및 모니터링 부족

**위치**: EC2 배포 환경 (`.github/workflows/deploy-staging-backend-ec2.yml`)

**현재 구현**:

PM2가 명령줄에서 직접 실행되며, 설정 파일이 없음:

```390:396:.github/workflows/deploy-staging-backend-ec2.yml
            NODE_ENV=staging pm2 start dist/main.js \
              --name sweet-order-backend \
              --update-env \
              --cwd $(pwd) || {
              echo "❌ PM2 시작 실패"
              rollback_deployment
            }
```

**문제점**:

- PM2 프로세스 상태 모니터링 부족
- 프로세스 재시작 정책 미명시
- PM2 로그 관리 전략 부재
- 프로세스 크래시 시 자동 복구 여부 불명확

**위험성**:

- 프로세스 크래시 시 서비스 다운타임 발생
- 로그 파일 누적으로 인한 디스크 공간 부족
- 프로세스 상태를 모니터링하지 못해 장애 감지 지연

**해결 방안**:

1. PM2 설정 파일(ecosystem.config.js) 구성:
   - 자동 재시작 설정 (max_restarts)
   - 로그 로테이션 설정
   - 메모리 제한 설정
2. PM2 모니터링 설정:
   - `pm2 monit` 또는 PM2 Plus 사용
   - CloudWatch Logs 연동
3. PM2 프로세스 상태 체크 스크립트 추가
4. 정기적인 로그 정리 작업 (cron)

---

## 🟢 경미한 문제점 (장기 개선 권장)

### 13. 로깅 전략 일관성 부족

**문제점**:

- 일부 서비스는 `Logger` 사용, 일부는 `console.log` 사용
- 로그 형식이 일관되지 않음
- 구조화된 로깅 부재

**해결 방안**:

1. 전역 로깅 전략 수립
2. 구조화된 로깅 (JSON 형식) 적용
3. 로그 레벨 표준화
4. CloudWatch Logs 연동

---

### 14. 환경 변수 타입 안전성 부족

**문제점**:

- 환경 변수를 `string | undefined`로만 처리
- 필수/선택 환경 변수 구분 없음
- 타입 안전성 부족

**해결 방안**:

1. 환경 변수 스키마 정의 (Zod 등 사용)
2. 타입 안전한 환경 변수 접근
3. 필수/선택 환경 변수 명시

---

### 15. 테스트 코드 부재

**문제점**:

- 단위 테스트, 통합 테스트 부재
- 운영 환경 배포 전 검증 어려움
- 리팩토링 시 회귀 테스트 불가능

**해결 방안**:

1. 단위 테스트 작성
2. 통합 테스트 작성
3. E2E 테스트 작성
4. CI/CD 파이프라인에 테스트 추가

---

### 16. 외부 API 호출 코드가 주석 처리됨

**위치**: 
- `apps/backend/src/modules/business/services/nts-api.service.ts` 48-87번 라인
- `apps/backend/src/modules/business/services/kftc-api.service.ts` 45-82번 라인

**문제점**:

- 실제 외부 API 호출 코드가 주석 처리되어 있음
- TODO 주석으로 "반드시 주석 해제 필요"라고 명시되어 있음
- 현재는 실제 API 호출 없이 항상 성공으로 처리됨

**위험성**:

- 운영 환경에서 실제 API 호출이 필요할 때 문제 발생 가능
- 사업자 등록번호 검증이 실제로 작동하지 않음

**해결 방안**:

1. 외부 API 호출 코드 주석 해제
2. 테스트 환경에서 API 호출 검증
3. 에러 처리 및 재시도 로직 추가

---

작성일: 2025-01-23
