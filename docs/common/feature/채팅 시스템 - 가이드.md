# 채팅 시스템 - 가이드

## 개요

스위트오더의 채팅 시스템은 사용자와 판매자 간의 실시간 메시지 교환을 지원합니다. 메시지 전송은 WebSocket(Socket.IO)을 통해 처리하고, 메시지 조회 및 채팅방 관리는 REST API를 통해 처리하는 하이브리드 아키텍처를 통해 안정성과 실시간성을 모두 확보했습니다.

## 아키텍처

### 전체 구조

```
┌─────────────┐         ┌─────────────┐
│  web-user   │         │ web-seller  │
│  (Next.js)  │         │ (React+Vite)│
└──────┬──────┘         └──────┬──────┘
       │                       │
       │  REST API             │  REST API
       │  WebSocket            │  WebSocket
       │                       │
       └───────────┬───────────┘
                   │
         ┌─────────▼─────────┐
         │   Backend (NestJS) │
         │                    │
         │  ┌──────────────┐ │
         │  │ ChatModule   │ │
         │  └──────────────┘ │
         │                    │
         │  ┌──────────────┐ │
         │  │ChatGateway   │ │
         │  │(Socket.IO)   │ │
         │  └──────────────┘ │
         └─────────┬─────────┘
                   │
         ┌─────────▼─────────┐
         │   PostgreSQL      │
         │  (ChatRoom, Message)│
         └───────────────────┘
```

## 백엔드 구조

### 모듈 구성

백엔드는 NestJS 기반으로 구성되어 있으며, 다음과 같은 구조로 채팅 기능을 제공합니다:

#### 1. ChatModule (`apps/backend/src/modules/chat/`)

채팅 관련 모든 기능을 통합하는 메인 모듈입니다.

**주요 구성 요소:**

- **ChatService** (Facade 패턴)
  - 채팅 관련 모든 기능을 통합하여 제공하는 메인 서비스
  - ChatRoomService와 ChatMessageService를 조합하여 사용
  - 외부에서는 ChatService만 사용하도록 인터페이스 단순화

- **ChatRoomService**
  - 채팅방 생성/조회
  - 채팅방 목록 조회 (사용자용/판매자용)
  - 채팅방 읽음 처리
  - 채팅방 메타데이터 관리 (마지막 메시지, 읽지 않은 메시지 수 등)

- **ChatMessageService**
  - 메시지 전송 및 검증
  - 메시지 목록 조회 (페이지네이션)
  - 메시지 길이 제한 (최대 1000자)
  - 채팅방 메타데이터 업데이트

- **ChatGateway** (WebSocket)
  - Socket.IO를 사용한 실시간 통신
  - 클라이언트 연결/해제 관리
  - 채팅방 조인/나가기 처리
  - 메시지 수신 및 처리 (`send-message` 이벤트 핸들러)
  - 메시지 브로드캐스트

- **ChatPermissionUtil**
  - 채팅방 접근 권한 검증
  - 사용자/판매자 권한 확인

#### 2. API 컨트롤러

**UserChatController** (`apps/backend/src/apis/user/controllers/chat.controller.ts`)

- 사용자용 채팅 API
- 엔드포인트: `/user/chat-room/*`
- 인증: USER, SELLER, ADMIN 역할 허용
- 제공 기능:
  - 채팅방 생성/조회
  - 채팅방 목록 조회
  - 메시지 목록 조회
  - 채팅방 읽음 처리

**SellerChatController** (`apps/backend/src/apis/seller/controllers/chat.controller.ts`)

- 판매자용 채팅 API
- 엔드포인트: `/seller/chat-room/*`
- 인증: SELLER, ADMIN 역할만 허용
- 제공 기능:
  - 채팅방 목록 조회 (스토어별)
  - 메시지 목록 조회
  - 채팅방 읽음 처리

### 데이터베이스 스키마

**ChatRoom 테이블:**

- `id`: 채팅방 고유 ID
- `userId`: 사용자 ID
- `storeId`: 스토어 ID
- `lastMessage`: 마지막 메시지 미리보기
- `lastMessageAt`: 마지막 메시지 시간
- `userUnread`: 사용자 읽지 않은 메시지 수
- `storeUnread`: 판매자 읽지 않은 메시지 수
- `createdAt`, `updatedAt`: 생성/수정 시간
- Unique 제약: `(userId, storeId)` - 사용자당 스토어당 하나의 채팅방만 존재

**Message 테이블:**

- `id`: 메시지 고유 ID
- `roomId`: 채팅방 ID (외래키)
- `text`: 메시지 내용 (최대 1000자)
- `senderId`: 발신자 ID
- `senderType`: 발신자 타입 (USER | STORE)
- `createdAt`: 생성 시간

## 프론트엔드 구조

### web-user (Next.js)

**주요 파일 구조:**

```
apps/web-user/src/features/chat/
├── apis/
│   └── chat.api.ts              # REST API 호출
├── services/
│   └── chat-socket.service.ts    # WebSocket 서비스 (싱글톤)
├── components/
│   ├── ChatRoom.tsx              # 채팅방 컴포넌트
│   └── ChatRoomList.tsx          # 채팅방 목록 컴포넌트
├── hooks/
│   └── queries/
│       └── useChat.ts            # React Query 훅
├── types/
│   └── chat.type.ts              # TypeScript 타입 정의
└── constants/
    └── chatQueryKeys.constant.ts # React Query 키
```

**페이지:**

- `/chat` - 채팅방 목록 페이지
- `/chat/[roomId]` - 채팅방 상세 페이지

### web-seller (React + Vite)

**주요 파일 구조:**

```
apps/web-seller/src/features/chat/
├── apis/
│   └── chat.api.ts              # REST API 호출
├── services/
│   └── chat-socket.service.ts    # WebSocket 서비스 (싱글톤)
├── components/
│   ├── ChatRoom.tsx              # 채팅방 컴포넌트
│   └── ChatRoomList.tsx          # 채팅방 목록 컴포넌트
├── hooks/
│   └── queries/
│       └── useChat.ts            # React Query 훅
├── types/
│   └── chat.type.ts              # TypeScript 타입 정의
└── constants/
    └── chatQueryKeys.constant.ts # React Query 키
```

**주요 차이점:**

- web-user와 web-seller는 거의 동일한 구조를 가지지만, API 엔드포인트와 토큰 관리 방식이 다릅니다.
- web-user는 Next.js의 서버 컴포넌트를 활용할 수 있지만, 채팅 기능은 클라이언트 컴포넌트로 구현되었습니다.

## 주요 플로우

### 1. 채팅방 생성/조회 플로우

```
사용자 → [스토어 상세 페이지에서 채팅 시작 버튼 클릭]
    ↓
프론트엔드 → POST /user/chat-room { storeId }
    ↓
백엔드 → ChatService.createOrGetChatRoom()
    ↓
ChatRoomService → upsert (userId, storeId)
    ↓
    ├─ 기존 채팅방 존재 → 기존 채팅방 ID 반환
    └─ 기존 채팅방 없음 → 새 채팅방 생성 후 ID 반환
    ↓
프론트엔드 → /chat/[roomId]로 리다이렉트
```

### 2. 메시지 전송 플로우

```
사용자 → [메시지 입력 후 전송 버튼 클릭]
    ↓
프론트엔드 → ChatSocketService.sendMessage(roomId, text)
    ↓
WebSocket → "send-message" 이벤트 전송 { roomId, text }
    ↓
백엔드 → ChatGateway.handleSendMessage()
    ↓
ChatService.sendMessage()
    ↓
ChatMessageService.sendMessage()
    ├─ 채팅방 권한 확인
    ├─ 메시지 검증 (길이, 빈 값 체크)
    ├─ 트랜잭션 시작
    │   ├─ Message 테이블에 메시지 저장
    │   └─ ChatRoom 테이블 메타데이터 업데이트
    │       ├─ lastMessage 업데이트
    │       ├─ lastMessageAt 업데이트
    │       └─ 상대방 unread 카운트 증가
    └─ 트랜잭션 커밋
    ↓
ChatGateway.broadcastMessage() → WebSocket으로 브로드캐스트
    ↓
해당 채팅방에 조인한 모든 클라이언트에게 "new-message" 이벤트 전송
    ↓
프론트엔드 → WebSocket 리스너가 메시지 수신하여 UI 업데이트
```

**중요한 점:**

- 메시지는 WebSocket을 통해 전송됩니다. 클라이언트에서 `send-message` 이벤트로 메시지를 전송합니다.
- 서버에서 메시지를 저장한 후, WebSocket으로 브로드캐스트하여 실시간성을 확보합니다.
- 이 방식으로 메시지의 영속성과 실시간성을 모두 보장합니다.

### 3. 메시지 수신 플로우

```
프론트엔드 → ChatSocketService.connect()
    ↓
WebSocket 연결 (Socket.IO)
    ├─ JWT 토큰 인증 (쿼리 파라미터 또는 헤더)
    └─ 연결 성공
    ↓
프론트엔드 → ChatSocketService.joinRoom(roomId)
    ↓
WebSocket → "join-room" 이벤트 전송
    ↓
백엔드 → ChatGateway.handleJoinRoom()
    ↓
Socket.IO Room에 조인 (room:${roomId})
    ↓
프론트엔드 → ChatSocketService.onNewMessage() 리스너 등록
    ↓
[다른 사용자가 메시지 전송]
    ↓
백엔드 → ChatGateway.broadcastMessage()
    ↓
해당 Room의 모든 클라이언트에게 "new-message" 이벤트 전송
    ↓
프론트엔드 → 리스너 콜백 실행 → UI 업데이트
```

### 4. 메시지 목록 조회 플로우 (무한 스크롤)

```
채팅방 입장
    ↓
프론트엔드 → GET /user/chat-room/[roomId]/messages?page=1&limit=50
    ↓
백엔드 → ChatService.getMessages()
    ↓
ChatMessageService.getMessages()
    ├─ 채팅방 권한 확인
    ├─ 페이지네이션 계산
    ├─ Message 테이블 조회 (최신순 정렬)
    └─ 응답 반환 (messages, meta)
    ↓
프론트엔드 → React Query InfiniteQuery로 관리
    ↓
사용자가 위로 스크롤 (이전 메시지 로드)
    ↓
프론트엔드 → fetchNextPage() 호출
    ↓
다음 페이지 요청 (page=2, page=3, ...)
```

**메시지 관리 전략:**

- 초기 로드 및 무한 스크롤: REST API로 조회한 메시지 (`initialAllMessages`)
- 실시간 수신: WebSocket으로 수신한 새 메시지 (`newAllMessages`)
- 두 배열을 합쳐서 화면에 표시 (`allMessages = [...initialAllMessages, ...newAllMessages]`)

### 5. 읽음 처리 플로우

```
채팅방 입장 시
    ↓
프론트엔드 → POST /user/chat-room/[roomId]/read
    ↓
백엔드 → ChatService.markChatRoomAsRead()
    ↓
ChatRoomService.markChatRoomAsRead()
    ├─ 채팅방 권한 확인
    └─ userUnread 또는 storeUnread를 0으로 초기화
    ↓
채팅방 나갈 때도 동일하게 읽음 처리
```

### 6. 채팅방 목록 조회 플로우

**사용자용:**

```
프론트엔드 → GET /user/chat-room
    ↓
백엔드 → ChatService.getChatRoomsByUserId()
    ↓
ChatRoomService.getChatRoomsByUserId()
    ├─ 해당 사용자의 모든 채팅방 조회
    ├─ 스토어 정보 포함 (JOIN)
    └─ lastMessageAt 기준 내림차순 정렬
```

**판매자용:**

```
프론트엔드 → GET /seller/chat-room/store/[storeId]
    ↓
백엔드 → ChatService.getChatRoomsByStoreId()
    ↓
ChatRoomService.getChatRoomsByStoreId()
    ├─ 스토어 소유권 확인
    ├─ 해당 스토어의 모든 채팅방 조회
    ├─ 사용자 정보 포함 (JOIN)
    └─ lastMessageAt 기준 내림차순 정렬
```

## WebSocket 연결 관리

### 연결 설정

**프론트엔드 (ChatSocketService):**

- Socket.IO 클라이언트 사용
- 연결 옵션:
  - `transports: ["websocket", "polling"]` - WebSocket 우선, 실패 시 polling
  - `reconnection: true` - 자동 재연결 활성화
  - `reconnectionDelay: 1000` - 재연결 시도 간격 1초
  - `reconnectionAttempts: 5` - 최대 재연결 시도 5회
- 인증: JWT 토큰을 쿼리 파라미터 또는 헤더로 전달
- 주요 메서드:
  - `connect()`: WebSocket 연결
  - `joinRoom(roomId)`: 채팅방 조인
  - `leaveRoom(roomId)`: 채팅방 나가기
  - `sendMessage(roomId, text)`: 메시지 전송 (WebSocket)
  - `onNewMessage(callback)`: 새 메시지 수신 리스너 등록

**백엔드 (ChatGateway):**

- Socket.IO 서버 사용
- Namespace: `/chat`
- 연결 시 JWT 토큰 검증
- 사용자 정보를 소켓 데이터에 저장 (`client.data.userId`, `client.data.userType`)
- 주요 이벤트 핸들러:
  - `join-room`: 채팅방 조인
  - `leave-room`: 채팅방 나가기
  - `send-message`: 메시지 수신 및 처리
  - `new-message`: 메시지 브로드캐스트 (서버 → 클라이언트)

### 재연결 처리

프론트엔드에서 재연결 시 자동으로 처리하는 기능:

1. **이벤트 리스너 복원**
   - 재연결 전 등록된 모든 이벤트 리스너를 내부 맵에 저장
   - 재연결 후 자동으로 리스너 재등록

2. **채팅방 자동 재조인**
   - 조인한 채팅방 목록을 `joinedRooms` Set에 저장
   - 재연결 시 모든 채팅방에 자동으로 재조인

### 연결 상태 관리

- `connectedUsers` Map: userId → Set<socketId>
  - 한 사용자가 여러 디바이스/탭에서 접속할 수 있도록 지원
  - 연결 해제 시 해당 socketId만 제거

## 권한 관리

### 채팅방 접근 권한

**ChatPermissionUtil.verifyChatRoomAccess()** 메서드로 권한을 확인합니다:

- **사용자 (user)**: 채팅방의 `userId`가 자신의 ID와 일치해야 함
- **판매자 (store)**: 채팅방의 `storeId`에 해당하는 스토어의 소유자가 자신이어야 함

모든 메시지 전송, 조회, 읽음 처리 시 권한을 확인합니다.

## 하이브리드 아키텍처의 장점

### REST API + WebSocket 조합

1. **메시지 영속성 보장**
   - 모든 메시지는 WebSocket을 통해 서버로 전송되어 데이터베이스에 저장
   - WebSocket 연결이 끊겨도 메시지 손실 없음 (재연결 후 이전 메시지 조회 가능)

2. **실시간성 확보**
   - 메시지 저장 후 즉시 WebSocket으로 브로드캐스트
   - 상대방이 실시간으로 메시지 수신

3. **안정성**
   - WebSocket 연결이 끊겨도 재연결 후 이전 메시지 조회 가능 (REST API)
   - 메시지 목록 조회는 REST API로 처리하여 안정성 확보

4. **일관성**
   - 메시지 전송은 WebSocket으로 처리하여 실시간성 확보
   - 메시지 조회는 REST API로 처리하여 안정성 확보
   - 각 기능에 적합한 통신 방식을 사용

## Redis 고려사항

### 현재 상태

현재는 AWS App Runner에서 **서버 인스턴스 1개만** 사용하고 있어 Redis를 사용하지 않습니다.

### Redis가 필요한 경우

**서버 인스턴스를 2개 이상으로 확장할 때는 Redis 도입이 필수입니다.**

#### 왜 필요한가?

1. **WebSocket 세션 공유**
   - 현재 각 서버 인스턴스는 독립적인 메모리에 WebSocket 연결 정보를 저장합니다.
   - 서버 A에 연결된 클라이언트가 서버 B로 요청을 보내면, 서버 B는 해당 클라이언트의 연결 정보를 알 수 없습니다.
   - Redis를 사용하면 모든 서버 인스턴스가 공유하는 세션 저장소를 만들 수 있습니다.

2. **메시지 브로드캐스트 문제**
   - 사용자 A가 서버 1에 연결되어 있고, 사용자 B가 서버 2에 연결되어 있다고 가정합니다.
   - 사용자 A가 메시지를 보내면 서버 1에서만 브로드캐스트가 발생합니다.
   - 서버 2에 연결된 사용자 B는 메시지를 받을 수 없습니다.
   - Redis Pub/Sub을 사용하면 모든 서버 인스턴스에 메시지를 브로드캐스트할 수 있습니다.

3. **채팅방 조인 정보 공유**
   - 현재 `connectedUsers` Map은 각 서버 인스턴스의 메모리에만 존재합니다.
   - 여러 서버 인스턴스가 있을 때, 특정 사용자가 어느 서버에 연결되어 있는지 알 수 없습니다.
   - Redis를 사용하면 모든 서버가 공유하는 연결 정보를 관리할 수 있습니다.

#### Redis 도입 시 구현 방안

1. **Redis Adapter 사용**
   - Socket.IO의 Redis Adapter를 사용하여 여러 서버 인스턴스 간 메시지 브로드캐스트
   - 각 서버는 Redis를 통해 다른 서버로 메시지를 전달

2. **세션 저장소**
   - WebSocket 연결 정보를 Redis에 저장
   - 모든 서버 인스턴스가 동일한 연결 정보에 접근 가능

3. **Pub/Sub 패턴**
   - 메시지 전송 시 Redis Pub/Sub으로 모든 서버에 알림
   - 각 서버는 자신에게 연결된 클라이언트에게만 메시지 전달

#### 예상 구조

```
┌─────────────┐         ┌─────────────┐
│  Server 1   │         │  Server 2   │
│  (App Runner)│         │  (App Runner)│
└──────┬──────┘         └──────┬──────┘
       │                       │
       └───────────┬───────────┘
                   │
         ┌─────────▼─────────┐
         │   Redis            │
         │  (ElastiCache)     │
         │                    │
         │  - Pub/Sub         │
         │  - Session Store   │
         └───────────────────┘
```

### 결론

- **현재 (서버 1개)**: Redis 불필요
- **서버 2개 이상**: Redis 필수
  - WebSocket 세션 공유
  - 메시지 브로드캐스트 문제 해결
  - 채팅방 조인 정보 공유

서버 인스턴스를 확장할 계획이 있다면, Redis 도입을 미리 준비해야 합니다.

## 주요 제한사항 및 규칙

1. **메시지 길이 제한**: 최대 1000자
2. **페이지네이션**: 기본 50개, 최대 100개
3. **채팅방 제약**: 사용자당 스토어당 하나의 채팅방만 존재 (Unique 제약)
4. **인증**: 모든 채팅 API는 JWT 토큰 인증 필수
5. **권한**: 채팅방 접근 시 사용자/판매자 권한 확인

## 향후 개선 가능한 사항

1. **파일 첨부**: 이미지, 파일 전송 기능
2. **알림**: 푸시 알림 연동
3. **검색**: 채팅방 내 메시지 검색
