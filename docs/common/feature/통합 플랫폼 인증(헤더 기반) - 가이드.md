# 통합 플랫폼 인증(헤더 기반) - 가이드

## 📋 개요

Sweet Order 플랫폼의 통합 인증 시스템은 사용자(User), 판매자(Seller), 관리자(Admin)의 3-way 분리된 API 구조에서 헤더 기반 토큰 전송을 통해 인증을 제공합니다.

## 🔄 토큰 전송 방식 (헤더 기반)

### 현재 방식

- **헤더 기반 토큰 전송**: Authorization 헤더에 Bearer 토큰을 포함하여 전송
- **토큰 저장**: 클라이언트에서 로컬 스토리지 또는 메모리에 저장
- **토큰 전송**: 모든 API 요청 시 `Authorization: Bearer {accessToken}` 헤더에 포함

### 헤더 방식 사용 이유

- **명시적 토큰 관리**: 클라이언트에서 토큰을 명시적으로 관리하고 전송
- **간단한 구현**: 쿠키 설정 없이 간단하게 구현 가능
- **표준 방식**: RESTful API에서 널리 사용되는 표준 인증 방식

## 🎯 주요 특징

- **헤더 기반 토큰 전송**: Authorization 헤더에 Bearer 토큰을 포함하여 전송
- **3-way API 분리**: User, Seller, Admin 역할별 독립적인 API
- **하나의 데코레이터로 모든 인증/권한 처리**

## 🖥️ 백엔드 처리

### 1. CORS 설정

**CORS 설정 옵션**:

```typescript
allowedHeaders: ["Content-Type", "X-Requested-With", "Authorization"], // 클라이언트에서 서버로 보낼 수 있는 헤더들 (Authorization 헤더 포함)
credentials: true, // 인증 헤더 등을 포함한 자격 증명을 CORS 요청에 포함할 수 있도록 허용
```

### 2. JWT 전략에서 헤더에서 토큰 추출

- 요청 시 Authorization 헤더에서 `Bearer {accessToken}` 추출
- 토큰이 없으면 401 에러 반환
- 토큰 검증 후 사용자 정보를 `req.user`에 저장

### 3. 로그인/회원가입 응답

- 응답에 `accessToken`과 `refreshToken`을 직접 반환
- 사용자 정보는 제외 (토큰만 반환)

### 4. 사용자 정보 조회 API (/me)

- Authorization 헤더의 Access Token을 사용하여 사용자 정보 조회
- 응답에 `accessToken`과 `user` 정보를 함께 반환

### 5. 로그아웃 API

- 클라이언트에서 토큰을 삭제하면 로그아웃 완료
- 서버에서는 별도 처리 불필요

### 6. API 권한 관리

3-way 분리된 API 구조(User, Seller, Admin)에서 역할 기반 접근 제어를 제공합니다. 하나의 통합된 `@Auth` 데코레이터를 통해 모든 인증과 권한을 효율적으로 관리할 수 있습니다.

**API 구조**:

- **User API**: `/v1/user/*` - 일반 사용자용 API
- **Seller API**: `/v1/seller/*` - 판매자용 API
- **Admin API**: `/v1/admin/*` - 관리자용 API

**권한 설정 예시**:

- **`@Auth({ isPublic: true })`**: 인증 없이 접근 가능한 엔드포인트
- **`@Auth({ isPublic: false })`**: 기본 인증 (모든 인증된 사용자)
- **`@Auth({ isPublic: false, roles: ['USER'] })`**: USER 역할만 접근 가능
- **`@Auth({ isPublic: false, roles: ['SELLER'] })`**: SELLER 역할만 접근 가능
- **`@Auth({ isPublic: false, roles: ['ADMIN'] })`**: ADMIN 역할만 접근 가능
- **`@Auth({ isPublic: false, roles: ['SELLER', 'ADMIN'] })`**: SELLER와 ADMIN 역할만 접근 가능

## 🌐 프론트엔드 처리

### 1. Axios 설정 (Authorization 헤더)

```typescript
// axios 인터셉터 설정
apiClient.interceptors.request.use(
  (config) => {
    const accessToken = localStorage.getItem("accessToken");
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  },
);
```

**중요**: 모든 API 요청 시 Authorization 헤더에 Bearer 토큰을 포함해야 합니다.

### 2. 토큰 저장 및 관리

- **토큰 저장**: 로그인/회원가입 성공 시 `accessToken`과 `refreshToken`을 로컬 스토리지에 저장
- **토큰 사용**: 모든 API 요청 시 `accessToken`을 Authorization 헤더에 포함
- **토큰 만료 처리**: Access Token이 만료되면 사용자는 다시 로그인해야 합니다.

### 3. 새로고침 시 로그인 유지

- 페이지 새로고침 시 저장된 `accessToken`을 사용하여 `/auth/me` API 호출
- 응답에서 받은 `accessToken`과 `user` 정보를 사용하여 로그인 상태 복원

## 📚 참고사항

### 🔧 기술적 구현 세부사항

- **헤더 기반 인증**: 토큰은 Authorization 헤더에 Bearer 토큰으로 전송
- **토큰 만료 시간**: Access Token 90일, Refresh Token 90일 (실제로는 Access Token만 사용)

### 🚨 주의사항

1. **Authorization 헤더 필수**: 모든 인증이 필요한 API 요청 시 Authorization 헤더에 Bearer 토큰을 포함해야 함
2. **CORS 설정 필수**: `credentials: true`, `allowedHeaders`에 "Authorization" 포함
3. **토큰 만료 시간**: Access Token 90일, Refresh Token 90일로 설정 (실제로는 Access Token만 사용)
4. **토큰 저장**: 클라이언트에서 안전하게 토큰을 저장하고 관리해야 함
5. **토큰 만료 처리**: Access Token이 만료되면 사용자는 다시 로그인해야 함
