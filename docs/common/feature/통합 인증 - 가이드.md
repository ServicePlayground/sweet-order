# 통합 인증 - 가이드

## 개요

Sweet Order 플랫폼의 통합 인증 시스템 가이드입니다. 이 문서는 다양한 로그인 방식(일반 로그인, 구글 OAuth, 휴대폰 인증)을 지원하는 통합 인증 시스템의 전체 아키텍처, 구현 방식, 보안 정책, 그리고 프론트엔드와 백엔드 간의 상호작용을 상세히 설명합니다.

### 주요 특징

- **통합 인증 시스템**: 일반 로그인 + 구글 OAuth + 휴대폰 인증을 하나의 시스템으로 통합
- **헤더 기반 토큰 관리**: Authorization 헤더에 Bearer 토큰을 포함하여 전송
- **새로고침 로그인 유지**: AuthInitializerProvider를 통한 자동 사용자 정보 복원
- **계정 연결**: 동일 휴대폰으로 가입된 일반/구글 계정 자동 연결
- **보안 강화**: Rate Limiting, 입력 검증, 에러 처리, 트랜잭션 처리 등 종합적인 보안 시스템

## 통합 로그인 플로우

### 1. 일반 회원가입 플로우 (계정 연결 포함)

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant DB as Database
    participant SMS as SMS Service

    U->>F: 아이디 입력
    F->>B: GET /auth/check-user-id
    B->>DB: userId 중복 확인
    DB-->>B: 중복 여부 반환
    B-->>F: { available: boolean }

    U->>F: 비밀번호, 휴대폰번호 입력
    F->>B: POST /auth/send-verification-code<br/>{ phone, purpose: "registration" }
    B->>DB: PhoneVerification 생성<br/>(기존 미인증 레코드 삭제 후 생성)
    B->>SMS: 인증번호 발송 (6자리, 5분 만료) [TODO: 실제 SMS 발송 미구현]
    SMS-->>U: 인증번호 수신 [TODO: 실제 SMS 발송 미구현]

    U->>F: 인증번호 입력
    F->>B: POST /auth/verify-phone-code<br/>{ phone, verificationCode, purpose: "registration" }
    B->>DB: 인증번호 검증 (phone, verificationCode, purpose로 조회)
    DB-->>B: 인증 결과 반환
    B-->>F: { message: "인증번호가 확인되었습니다." }

    F->>B: POST /auth/register
    Note over B: userId, password, phone 전달
    B->>B: 휴대폰 인증 상태 확인<br/>(purpose: "registration", 1시간 이내 인증만 유효)
    alt 인증 만료 (1시간 초과)
        B-->>F: 400 - 휴대폰 인증 필요
    else 인증 유효
        B->>DB: 휴대폰 중복 확인
        alt 휴대폰 중복
            alt 구글 계정만 존재
                B->>DB: 기존 구글 계정에 일반 로그인 정보 추가 (트랜잭션)
                B->>B: JWT 토큰 생성 (90일 만료)
                B-->>F: { accessToken, refreshToken }
                Note over F: 통합 계정으로 로그인 완료
            else 일반 계정 존재
                B-->>F: 409 - PHONE_GENERAL_ACCOUNT_EXISTS 오류
            else 둘 다 존재
                B-->>F: 409 - PHONE_MULTIPLE_ACCOUNTS 오류
            end
        else 휴대폰 신규
            B->>DB: 새 User 생성 (트랜잭션)
            B->>B: JWT 토큰 생성 (90일 만료)
            B-->>F: { accessToken, refreshToken }
            F-->>U: 회원가입 완료 + 자동 로그인
        end
    end
```

### 2. 일반 로그인 플로우

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant DB as Database

    U->>F: userId, password 입력
    F->>B: POST /auth/login
    B->>DB: User 테이블 조회 (userId)
    DB-->>B: 사용자 정보 반환

    alt 계정 없음
        B-->>F: 400 - 계정 없음 오류
    else 계정 존재
        B->>B: 비밀번호 검증 (bcrypt)
        alt 비밀번호 틀림
            B-->>F: 401 - 인증 실패
        else 비밀번호 맞음
            alt 휴대폰 미인증
                B-->>F: 400 - 휴대폰 인증 필요
            else 휴대폰 인증 완료
                B->>B: JWT 토큰 생성 (90일 만료)
                B->>DB: lastLoginAt 업데이트 (트랜잭션)
                B-->>F: { accessToken, refreshToken }
                F-->>U: 로그인 성공
            end
        end
    end
```

### 3. 구글 로그인 플로우

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant G as Google OAuth
    participant DB as Database

    U->>F: 구글 로그인 버튼 클릭
    F->>G: OAuth 인증 요청
    G-->>F: Authorization Code 반환

    F->>B: POST /auth/google/login
    Note over B: Authorization Code 전달
    B->>G: 토큰 교환 (exchangeCodeForToken)
    G-->>B: 구글 사용자 정보 반환

    B->>DB: User 조회 (googleId)
    DB-->>B: 사용자 정보 반환

    alt 구글 ID 없음
        B-->>F: 400 - { message: "휴대폰 인증 필요", googleId, googleEmail }
        Note over F: 소셜 회원가입 플로우로 이동
    else 구글 ID 존재
        alt 휴대폰 미인증
            B-->>F: 400 - { message: "휴대폰 인증 필요", googleId, googleEmail }
        else 휴대폰 인증 완료
            B->>B: JWT 토큰 생성 (90일 만료)
            B->>DB: lastLoginAt 업데이트 (트랜잭션)
            B-->>F: { accessToken, refreshToken }
            F-->>U: 로그인 성공
        end
    end
```

### 4. 구글 회원가입 플로우 (계정 연결 포함)

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant DB as Database
    participant SMS as SMS Service

    Note over U,F: 구글 로그인에서 휴대폰 인증 필요 응답 후

    U->>F: 휴대폰번호 입력
    F->>B: POST /auth/send-verification-code<br/>{ phone, purpose: "google_registration" }
    B->>DB: PhoneVerification 생성<br/>(기존 미인증 레코드 삭제 후 생성)
    B->>SMS: 인증번호 발송 (6자리, 5분 만료) [TODO: 실제 SMS 발송 미구현]
    SMS-->>U: 인증번호 수신 [TODO: 실제 SMS 발송 미구현]

    U->>F: 인증번호 입력
    F->>B: POST /auth/verify-phone-code<br/>{ phone, verificationCode, purpose: "google_registration" }
    B->>DB: 인증번호 검증 (phone, verificationCode, purpose로 조회)
    DB-->>B: 인증 결과 반환
    B-->>F: { message: "인증번호가 확인되었습니다." }

    F->>B: POST /auth/google/register
    Note over B: googleId, googleEmail, phone 전달
    B->>B: 휴대폰 인증 상태 확인<br/>(purpose: "google_registration", 1시간 이내 인증만 유효)
    alt 인증 만료 (1시간 초과)
        B-->>F: 400 - 휴대폰 인증 필요
    else 인증 유효
        B->>DB: 휴대폰 중복 확인 (트랜잭션)
        alt 휴대폰 중복
            alt 일반 계정만 존재
                B->>DB: 기존 일반 계정에 구글 로그인 정보 추가 (트랜잭션)
                B->>B: JWT 토큰 생성 (90일 만료)
                B-->>F: { accessToken, refreshToken }
                Note over F: 통합 계정으로 로그인 완료
            else 구글 계정 존재
                B-->>F: 409 - PHONE_GOOGLE_ACCOUNT_EXISTS 오류
            else 둘 다 존재
                B-->>F: 409 - PHONE_MULTIPLE_ACCOUNTS 오류
            end
        else 휴대폰 신규
            B->>DB: 새 User 생성 (트랜잭션)
            B->>B: JWT 토큰 생성 (90일 만료)
            B-->>F: { accessToken, refreshToken }
            F-->>U: 회원가입 완료 + 자동 로그인
        end
    end
```

### 5. 계정 찾기 플로우

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant DB as Database
    participant SMS as SMS Service

    U->>F: 휴대폰번호 입력
    F->>B: POST /auth/send-verification-code<br/>{ phone, purpose: "id_find" }
    B->>DB: PhoneVerification 생성<br/>(기존 미인증 레코드 삭제 후 생성)
    B->>SMS: 인증번호 발송 (6자리, 5분 만료) [TODO: 실제 SMS 발송 미구현]
    SMS-->>U: 인증번호 수신 [TODO: 실제 SMS 발송 미구현]

    U->>F: 인증번호 입력
    F->>B: POST /auth/verify-phone-code<br/>{ phone, verificationCode, purpose: "id_find" }
    B->>DB: 인증번호 검증 (phone, verificationCode, purpose로 조회)
    DB-->>B: 인증 결과 반환
    B-->>F: { message: "인증번호가 확인되었습니다." }

    F->>B: GET /auth/find-account?phone=010-1234-5678
    Note over B: phone을 쿼리 파라미터로 전달
    B->>B: 휴대폰 인증 상태 확인<br/>(purpose: "id_find", 1시간 이내 인증만 유효)
    alt 인증 만료 (1시간 초과)
        B-->>F: 400 - 휴대폰 인증 필요
    else 인증 유효
        B->>DB: User 조회 (phone)
        DB-->>B: 사용자 정보 반환
        alt 계정 없음
            B-->>F: 400 - 계정 없음 오류
        else 계정 존재
            alt 일반 로그인 계정
                B-->>F: { userId: "user123" }
            else 구글 로그인 계정
                B-->>F: { googleEmail: "user@gmail.com" }
            else 둘 다 존재
                B-->>F: { userId: "user123", googleEmail: "user@gmail.com" }
            end
        end
    end
```

### 6. 비밀번호 변경 플로우

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant DB as Database
    participant SMS as SMS Service

    U->>F: 아이디, 휴대폰번호 입력
    F->>B: POST /auth/send-verification-code<br/>{ phone, purpose: "password_recovery" }
    B->>DB: PhoneVerification 생성<br/>(기존 미인증 레코드 삭제 후 생성)
    B->>SMS: 인증번호 발송 (6자리, 5분 만료) [TODO: 실제 SMS 발송 미구현]
    SMS-->>U: 인증번호 수신 [TODO: 실제 SMS 발송 미구현]

    U->>F: 인증번호 입력
    F->>B: POST /auth/verify-phone-code<br/>{ phone, verificationCode, purpose: "password_recovery" }
    B->>DB: 인증번호 검증 (phone, verificationCode, purpose로 조회)
    DB-->>B: 인증 결과 반환
    B-->>F: { message: "인증번호가 확인되었습니다." }

    U->>F: 새 비밀번호 입력
    F->>B: POST /auth/change-password
    Note over B: userId, phone, newPassword 전달
    B->>DB: User 조회 (userId)
    DB-->>B: 사용자 정보 반환

    alt 계정 없음
        B-->>F: 400 - 계정 없음 오류
    else 계정 존재
        B->>B: 아이디-휴대폰 매칭 확인
        alt 매칭 실패
            B-->>F: 400 - 아이디-휴대폰 불일치
        else 매칭 성공
            B->>B: 휴대폰 인증 상태 확인<br/>(purpose: "password_recovery", 1시간 이내 인증만 유효)
            alt 인증 만료 (1시간 초과)
                B-->>F: 400 - 휴대폰 인증 필요
            else 인증 유효
                B->>B: 새 비밀번호 해시화 (bcrypt)
                B->>DB: passwordHash 업데이트 (트랜잭션)
                B-->>F: { message: "비밀번호가 성공적으로 변경되었습니다." }
                F-->>U: 변경 성공
            end
        end
    end
```

### 7. 휴대폰 번호 변경 플로우

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant DB as Database
    participant SMS as SMS Service

    Note over U,F: 로그인 상태에서만 가능 (JWT 토큰 필요)

    U->>F: 새 휴대폰번호 입력
    F->>B: POST /auth/send-verification-code<br/>{ phone, purpose: "phone_change" }
    B->>DB: PhoneVerification 생성<br/>(기존 미인증 레코드 삭제 후 생성)
    B->>SMS: 인증번호 발송 (6자리, 5분 만료) [TODO: 실제 SMS 발송 미구현]
    SMS-->>U: 인증번호 수신 [TODO: 실제 SMS 발송 미구현]

    U->>F: 인증번호 입력
    F->>B: POST /auth/verify-phone-code<br/>{ phone, verificationCode, purpose: "phone_change" }
    B->>DB: 인증번호 검증 (phone, verificationCode, purpose로 조회)
    DB-->>B: 인증 결과 반환
    B-->>F: { message: "인증번호가 확인되었습니다." }

    F->>B: POST /auth/change-phone
    Note over B: newPhone 전달 + JWT 토큰
    B->>B: JWT 토큰 검증
    B->>DB: 새 휴대폰 중복 확인

    alt 휴대폰 중복
        B-->>F: 409 - 휴대폰 중복 오류
    else 휴대폰 신규
        B->>B: 휴대폰 인증 상태 확인<br/>(purpose: "phone_change", 1시간 이내 인증만 유효)
        alt 인증 만료 (1시간 초과)
            B-->>F: 400 - 휴대폰 인증 필요
        else 인증 유효
            B->>DB: User.phone 업데이트 (트랜잭션)
            B-->>F: { message: "휴대폰 번호가 변경되었습니다." }
            F-->>U: 변경 성공
        end
    end
```

### 8. 토큰 관리

**참고**: 현재 버전에서는 토큰 갱신 API가 제거되었습니다. Access Token이 만료되면 사용자는 다시 로그인해야 합니다.

### 9. 새로고침 시 로그인 유지 플로우

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend

    Note over U,F: 페이지 새로고침 또는 앱 초기화

    F->>F: AuthInitializerProvider 컴포넌트 마운트
    F->>F: useMe 훅 실행 (React Query)
    F->>B: GET /auth/me
    Note over F: Authorization: Bearer {accessToken} 헤더 포함
    B->>B: JWT 토큰 검증

    alt Access Token 유효
        B->>B: 데이터베이스에서 사용자 정보 조회
        B-->>F: { accessToken, user: 사용자정보 }
        F->>F: Zustand 스토어에 로그인 정보 저장
        F->>F: isAuthenticated = true 설정
        F-->>U: 로그인 상태 유지
    else Access Token 무효
        B-->>F: 401 - 인증 실패
        F->>F: 로그아웃 상태 유지
        F-->>U: 로그인 페이지로 이동
    end
```

## 프론트엔드 인증 처리 상세

### 1. 토큰 관리

#### HTTP 상태 코드 구분

- **401**: 인증 실패 (토큰 없음/액세스 토큰 검증 실패/액세스 토큰 만료/role 권한없음/기타 권한 없음)

#### 토큰 저장 및 전송

- **토큰 저장**: 로컬 스토리지 또는 메모리에 저장
- **토큰 전송**: 모든 API 요청 시 `Authorization: Bearer {accessToken}` 헤더에 포함
- **토큰 만료 처리**: Access Token이 만료되면 사용자는 다시 로그인해야 합니다.

#### axios 설정

```typescript
// apps/web-user/src/common/config/axios.config.ts
apiClient.interceptors.request.use(
  (config) => {
    // 로컬 스토리지에서 토큰 가져오기
    const accessToken = localStorage.getItem("accessToken");
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  },
);
```

## 보안 시스템

### 1. 휴대폰 인증 보안

- **인증번호 만료**: 5분 후 자동 만료
- **인증 상태 유효기간**: 인증 완료 후 1시간 이내만 유효
  - 회원가입, 계정 찾기, 비밀번호 변경, 휴대폰 번호 변경 시 적용
  - 1시간 초과 시 재인증 필요
- **인증 목적별 구분 (purpose)**:
  - `registration`: 일반 회원가입
  - `google_registration`: 구글 회원가입
  - `password_recovery`: 비밀번호 찾기/변경
  - `id_find`: 아이디 찾기
  - `phone_change`: 휴대폰 번호 변경
  - 각 목적별로 독립적인 인증 상태 관리
- **시도 횟수 제한**:
  - 1분당 10회 제한 (전역 Rate Limiting과 별도)
- **본인인증 API**: 신뢰할 수 있는 인증 서비스 연동 (현재 TODO 상태 - 실제 SMS 발송 미구현)
- **인증 완료 시 정리**: 같은 목적의 기존 미인증 레코드 자동 삭제 후 새 인증번호 생성
- **데이터베이스 구조**:
  - `PhoneVerification` 테이블에 `purpose` 필드로 인증 목적 구분

### 2. 비밀번호 보안

- **해시 알고리즘**: bcrypt 사용

### 3. JWT 토큰 보안

- **토큰 전송 방식**: Authorization 헤더에 Bearer 토큰을 포함하여 전송
- **토큰 타입 구분**: ACCESS, REFRESH 토큰 구분 (응답에는 둘 다 포함되지만 실제로는 ACCESS 토큰만 사용)

### 4. Rate Limiting

- **전역 제한**: 1분당 100회 (모든 API)
- **휴대폰 인증 특별 제한**: 1분당 10회 (send-verification-code)
- **구현**: @nestjs/throttler 사용

### 5. 입력 검증

- **휴대폰 형식**: 010-019로 시작하는 10-11자리 검증 (하이픈, 공백 자동 제거)
- **아이디 형식**: 4-20자의 영문, 숫자, 언더스코어만 사용 가능
- **비밀번호 형식**: 8자 이상의 영문 대소문자, 숫자, 특수문자(@$!%\*?&) 포함 필수
- **인증번호 형식**: 6자리 숫자 포함 필수

### 6. 계정 연결 보안

- **휴대폰 기반 통합**: 동일 휴대폰으로 가입된 계정(일반/소셜) 자동 연결

### 7. 에러 처리

- **HTTP 상태 코드**: 적절한 상태 코드 사용
  - **401**: 인증 실패 (토큰 없음/액세스 토큰 검증 실패/액세스 토큰 만료/role 권한없음/기타 권한 없음)
  - **400, 409, 429**: 기타 에러 상황
- **토큰 만료 처리**: Access Token이 만료되면 사용자는 다시 로그인해야 합니다.

## 보안 모니터링

### 1. 로그인 시도 모니터링

- **의심스러운 IP 주소 모니터링**: Rate Limiting을 통한 자동 차단

### 2. 데이터베이스 모니터링

- **트랜잭션 처리**: 모든 중요한 작업을 트랜잭션으로 처리

이 가이드는 Sweet Order 플랫폼의 통합 인증 시스템을 위한 완전한 구현 가이드를 제공하며, 실제 구현된 코드를 반영하여 보안성과 확장성을 고려하여 설계되었습니다. 모든 API 엔드포인트가 구현되어 있으며, 상세한 요청/응답 구조와 에러 케이스, 프론트엔드와 백엔드 간의 상호작용이 문서화되어 있습니다.
